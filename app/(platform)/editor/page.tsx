'use client'

import { useState, useEffect, useRef, useCallback } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import dynamic from 'next/dynamic'
import './editor.css'

const TiptapEditor = dynamic(() => import('@/components/editor/tiptap-editor'), {
  ssr: false,
  loading: () => <div className="te-loading" />,
})

const AISidebar = dynamic(() => import('@/components/editor/ai-sidebar').then(m => ({ default: m.AISidebar })), {
  ssr: false,
  loading: () => null,
})

const EVENT_TO_CATEGORY: Record<string, string> = {
  'TRANSFER': 'transfers', 'CONTRACT': 'transfers', 'INJURY': 'injuries',
  'MATCH_PREVIEW': 'matches', 'MATCH_RESULT': 'matches', 'POST_MATCH_REACTION': 'matches',
  'BREAKING': 'news', 'SCANDAL': 'news', 'DISCIPLINE': 'news', 'RECORD': 'news',
  'MANAGERIAL': 'news', 'TACTICAL': 'news',
}

export default function EditorPage() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const [title, setTitle] = useState('')
  const [subtitle, setSubtitle] = useState('')
  const [content, setContent] = useState<Record<string, unknown>>({})
  const [initialContent, setInitialContent] = useState<Record<string, unknown> | undefined>(undefined)
  const [saving, setSaving] = useState(false)
  const [siteId, setSiteId] = useState<string | null>(null)
  const [categories, setCategories] = useState<Array<{ id: string; name: string; slug?: string; icon?: string }>>([])
  const [categoryId, setCategoryId] = useState('')
  const [showAI, setShowAI] = useState(false)
  const [aiResult, setAiResult] = useState<{ model?: string; tokensIn?: number; tokensOut?: number } | null>(null)
  const [sendNewsletter, setSendNewsletter] = useState(false)
  const [showSEO, setShowSEO] = useState(false)
  const [metaTitle, setMetaTitle] = useState('')
  const [metaDesc, setMetaDesc] = useState('')
  const [slug, setSlug] = useState('')
  const [scheduledAt, setScheduledAt] = useState('')
  const [showSchedule, setShowSchedule] = useState(false)
  const [smartNotice, setSmartNotice] = useState<string | null>(null)
  const [prefilledPrompt, setPrefilledPrompt] = useState('')
  const [autoGenerate, setAutoGenerate] = useState(false)
  const editorRef = useRef<unknown>(null)
  const autoSaveTimer = useRef<ReturnType<typeof setTimeout> | null>(null)
  const articleIdRef = useRef<string | null>(null)

  function slugify(text: string): string {
    return text.toLowerCase().replace(/[ƒçƒá]/g, 'c').replace(/[≈°]/g, 's').replace(/[≈æ]/g, 'z')
      .replace(/[ƒë]/g, 'dj').replace(/[^\w\s-]/g, '').replace(/\s+/g, '-').replace(/-+/g, '-').trim().slice(0, 100)
  }

  // Load site & categories
  useEffect(() => {
    fetch('/api/site').then((r) => r.json() as Promise<{ id?: string; categories?: Array<{ id: string; name: string; slug?: string; icon?: string }> }>).then((data) => {
      if (data.id) {
        setSiteId(data.id)
        const cats = data.categories || []
        setCategories(cats)
        const eventType = searchParams.get('eventType')
        if (eventType) {
          const targetSlug = EVENT_TO_CATEGORY[eventType]
          if (targetSlug) {
            const match = cats.find((c: { slug?: string }) => c.slug === targetSlug)
            if (match) setCategoryId(match.id)
          }
        }
      }
    }).catch(console.error)
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  // Handle pre-filled content from Newsroom/Calendar
  useEffect(() => {
    // Smart generate mode (from Newsroom "Write" button)
    if (searchParams.get('smartGenerate') === 'true') {
      try {
        const raw = sessionStorage.getItem('smartArticle')
        if (raw) {
          const data = JSON.parse(raw)
          if (data.title) setTitle(data.title)
          if (data.tiptapContent) { setContent(data.tiptapContent); setInitialContent(data.tiptapContent) }
          if (data.model) setAiResult({ model: data.model, tokensIn: data.tokensIn, tokensOut: data.tokensOut })
          setSmartNotice('Article generated by AI ‚Äî review and edit before publishing')
          setTimeout(() => setSmartNotice(null), 6000)
          sessionStorage.removeItem('smartArticle')
        }
      } catch {}
    }

    // Rewrite mode
    if (searchParams.get('mode') === 'rewrite') {
      try {
        const raw = sessionStorage.getItem('diurna_rewrite_source')
        if (raw) {
          const data = JSON.parse(raw)
          sessionStorage.removeItem('diurna_rewrite_source')
          setPrefilledPrompt(`Rewrite: ${data.title}`)
          setShowAI(true)
          runAutoGenerate(data, 'rewrite')
        }
      } catch {}
    }

    // Headline-only mode
    if (searchParams.get('mode') === 'headline-only') {
      try {
        const raw = sessionStorage.getItem('diurna_headline_only')
        if (raw) {
          const data = JSON.parse(raw)
          sessionStorage.removeItem('diurna_headline_only')
          setPrefilledPrompt(`Headline: ${data.title}`)
          setShowAI(true)
          runAutoGenerate(data, 'headline-only')
        }
      } catch {}
    }

    // Combined sources mode
    if (searchParams.get('mode') === 'combined') {
      try {
        const raw = sessionStorage.getItem('diurna_combined_sources')
        if (raw) {
          const sources = JSON.parse(raw)
          sessionStorage.removeItem('diurna_combined_sources')
          if (sources.length > 0) {
            setPrefilledPrompt(`Combined from ${sources.length} sources`)
            setShowAI(true)
            runCombinedGenerate(sources)
          }
        }
      } catch {}
    }

    // Cluster context from Newsroom
    if (searchParams.get('clusterId') && searchParams.get('title')) {
      const clusterTitle = searchParams.get('title') || ''
      const clusterSummary = searchParams.get('summary') || ''
      setTitle(clusterTitle)
      setPrefilledPrompt(`Write an article about: ${clusterTitle}${clusterSummary ? `\n\nContext: ${clusterSummary}` : ''}`)
      setShowAI(true)
    }

    const promptParam = searchParams.get('prompt')
    if (promptParam && !searchParams.get('smartGenerate') && searchParams.get('mode') !== 'combined') {
      setPrefilledPrompt(promptParam)
      setShowAI(true)
      setAutoGenerate(true)
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  async function runAutoGenerate(data: { title: string; sourceText?: string; domain?: string }, mode: string) {
    try {
      const body: Record<string, unknown> = {
        topic: data.title, category: 'Sport',
        articleType: mode === 'headline-only' ? 'breaking' : 'report',
        mode: mode === 'rewrite' ? 'rewrite' : 'single',
      }
      if (mode === 'rewrite' && data.sourceText) {
        body.sourceContext = data.sourceText
        body.sourceDomain = data.domain
      }
      const res = await fetch('/api/ai/smart-generate', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      })
      const result = await res.json() as { title?: string; tiptapContent?: Record<string, unknown>; model?: string; tokensIn?: number; tokensOut?: number }
      if (result.title) setTitle(result.title)
      if (result.tiptapContent) { setContent(result.tiptapContent); setInitialContent(result.tiptapContent) }
      setAiResult({ model: result.model, tokensIn: result.tokensIn, tokensOut: result.tokensOut })
      setSmartNotice(mode === 'rewrite' ? `Rewritten from ${data.domain || 'source'}` : 'Generated from headline ‚Äî review carefully')
      setTimeout(() => setSmartNotice(null), 8000)
    } catch {
      setTitle(data.title)
    }
  }

  async function runCombinedGenerate(sources: { title: string; source: string; role: string }[]) {
    try {
      const primary = sources.find(s => s.role === 'primary')
      const res = await fetch('/api/ai/smart-generate', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          topic: primary?.title || sources[0].title, category: 'Sport',
          articleType: 'report', mode: 'combined', sources,
        }),
      })
      const data = await res.json() as { title?: string; tiptapContent?: Record<string, unknown>; model?: string; tokensIn?: number; tokensOut?: number }
      if (data.title) setTitle(data.title)
      if (data.tiptapContent) { setContent(data.tiptapContent); setInitialContent(data.tiptapContent) }
      setAiResult({ model: data.model, tokensIn: data.tokensIn, tokensOut: data.tokensOut })
      setSmartNotice('Combined article generated ‚Äî review before publishing')
      setTimeout(() => setSmartNotice(null), 6000)
    } catch {}
  }

  // Auto-slug from title
  useEffect(() => {
    if (title && !slug) setSlug(slugify(title))
  }, [title, slug])

  // Auto-save every 30s (only if article was already created)
  const autoSave = useCallback(async () => {
    if (!articleIdRef.current || !title.trim() || saving) return
    try {
      await fetch(`/api/articles/${articleIdRef.current}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title, content }),
      })
    } catch {}
  }, [title, content, saving])

  useEffect(() => {
    if (autoSaveTimer.current) clearTimeout(autoSaveTimer.current)
    autoSaveTimer.current = setTimeout(autoSave, 30000)
    return () => { if (autoSaveTimer.current) clearTimeout(autoSaveTimer.current) }
  }, [autoSave])

  // localStorage backup
  useEffect(() => {
    if (title || Object.keys(content).length > 0) {
      try {
        localStorage.setItem('diurna_editor_backup', JSON.stringify({ title, subtitle, content, categoryId, timestamp: Date.now() }))
      } catch {}
    }
  }, [title, subtitle, content, categoryId])

  // Restore from localStorage on mount if no other content source
  useEffect(() => {
    if (!searchParams.get('smartGenerate') && !searchParams.get('mode') && !searchParams.get('clusterId')) {
      try {
        const backup = localStorage.getItem('diurna_editor_backup')
        if (backup) {
          const data = JSON.parse(backup)
          if (data.timestamp && Date.now() - data.timestamp < 3600000 && data.title) {
            setTitle(data.title)
            setSubtitle(data.subtitle || '')
            if (data.content && Object.keys(data.content).length > 0) {
              setContent(data.content)
              setInitialContent(data.content)
            }
            if (data.categoryId) setCategoryId(data.categoryId)
          }
        }
      } catch {}
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  // Keyboard shortcuts
  useEffect(() => {
    const handler = (e: KeyboardEvent) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 's') {
        e.preventDefault()
        handleSave('DRAFT')
      }
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
        e.preventDefault()
        handleSave('PUBLISHED')
      }
    }
    document.addEventListener('keydown', handler)
    return () => document.removeEventListener('keydown', handler)
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [title, content, siteId])

  async function handleSave(status: 'DRAFT' | 'SCHEDULED' | 'PUBLISHED') {
    if (!title.trim() || !siteId) return
    setSaving(true)
    try {
      const body: Record<string, unknown> = {
        title, content, siteId,
        categoryId: categoryId || undefined,
        status,
        aiGenerated: !!aiResult,
        aiModel: aiResult?.model,
        metaTitle: metaTitle || undefined,
        metaDescription: metaDesc || undefined,
      }
      if (status === 'SCHEDULED' && scheduledAt) body.scheduledAt = scheduledAt

      if (articleIdRef.current) {
        // Update existing
        const res = await fetch(`/api/articles/${articleIdRef.current}`, {
          method: 'PATCH', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body),
        })
        if (res.ok) {
          if (sendNewsletter && status === 'PUBLISHED') {
            fetch('/api/newsletter/send', {
              method: 'POST', headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ articleId: articleIdRef.current }),
            }).catch(console.error)
          }
          localStorage.removeItem('diurna_editor_backup')
          router.push('/articles')
          router.refresh()
        }
      } else {
        // Create new
        const res = await fetch('/api/articles', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body),
        })
        if (res.ok) {
          const article = await res.json() as { id?: string }
          articleIdRef.current = article.id ?? null
          if (sendNewsletter && status === 'PUBLISHED' && article.id) {
            fetch('/api/newsletter/send', {
              method: 'POST', headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ articleId: article.id }),
            }).catch(console.error)
          }
          localStorage.removeItem('diurna_editor_backup')
          router.push('/articles')
          router.refresh()
        }
      }
    } catch {} finally { setSaving(false) }
  }

  function handleAIGenerate(result: { title?: string; content?: Record<string, unknown>; model?: string; tokensIn?: number; tokensOut?: number }) {
    if (result.title) setTitle(result.title)
    if (result.content) { setContent(result.content); setInitialContent(result.content) }
    if (result.model) setAiResult({ model: result.model, tokensIn: result.tokensIn, tokensOut: result.tokensOut })
  }

  return (
    <div className="editor-layout">
      {/* Top bar */}
      <div className="ed-top">
        <button className="ed-back" onClick={() => router.push('/newsroom')}>‚Üê Back</button>
        <div className="ed-title-bar">
          {title || 'New Article'}
          {aiResult && <span className="badge-ai">AI</span>}
          <span className="badge-status draft">Draft</span>
        </div>
        <button className="ed-btn ed-btn-secondary" onClick={() => handleSave('DRAFT')} disabled={saving || !title.trim()}>
          üíæ {saving ? 'Saving...' : 'Save Draft'}
        </button>
        <button className="ed-btn ed-btn-secondary" onClick={() => setShowSchedule(true)}>üìÖ Schedule</button>
        <label className="ed-nl-check">
          <input type="checkbox" checked={sendNewsletter} onChange={(e) => setSendNewsletter(e.target.checked)} />
          <span>üìß</span>
        </label>
        <button className="ed-btn ed-btn-primary" onClick={() => handleSave('PUBLISHED')} disabled={saving || !title.trim()}>
          ‚ö° {saving ? 'Publishing...' : 'Publish'}
        </button>
      </div>

      {/* Notice bar */}
      {smartNotice && (
        <div className="ed-notice">
          <span>‚ú® {smartNotice}</span>
          <button onClick={() => setSmartNotice(null)}>√ó</button>
        </div>
      )}

      <div className="editor-main">
        {/* LEFT: Editor */}
        <div className="editor-left">
          <div className="ed-form">
            <input type="text" className="ed-title-input" placeholder="Naslov ƒçlanka..."
              value={title} onChange={(e) => { setTitle(e.target.value); setSlug(slugify(e.target.value)) }} />
            <input type="text" className="ed-subtitle-input" placeholder="Podnaslov (opcionalno)"
              value={subtitle} onChange={(e) => setSubtitle(e.target.value)} />
            <div className="ed-meta">
              <select className="ed-select" value={categoryId} onChange={(e) => setCategoryId(e.target.value)}>
                <option value="">No category</option>
                {categories.map((cat) => (
                  <option key={cat.id} value={cat.id}>{cat.icon ? `${cat.icon} ` : ''}{cat.name}</option>
                ))}
              </select>
            </div>
            <TiptapEditor
              content={initialContent && Object.keys(initialContent).length > 0 ? initialContent : undefined}
              onChange={(json) => setContent(json)}
              onEditorReady={(e) => { editorRef.current = e }}
              placeholder="Start writing your article..."
            />
          </div>

          {/* Bottom bar: SEO */}
          <div className="ed-bottom">
            <button className="ed-seo-toggle" onClick={() => setShowSEO(!showSEO)}>
              {showSEO ? '‚ñæ' : '‚ñ∏'} SEO Settings
            </button>
            {showSEO && (
              <div className="ed-seo-panel">
                <div className="ed-seo-field">
                  <label>Meta Title</label>
                  <input type="text" value={metaTitle} onChange={(e) => setMetaTitle(e.target.value)} placeholder={title} maxLength={60} />
                  <span className="ed-seo-count">{(metaTitle || title).length}/60</span>
                </div>
                <div className="ed-seo-field">
                  <label>Meta Description</label>
                  <textarea value={metaDesc} onChange={(e) => setMetaDesc(e.target.value)} placeholder="Article description for search engines..." maxLength={155} rows={2} />
                  <span className="ed-seo-count">{metaDesc.length}/155</span>
                </div>
                <div className="ed-seo-field">
                  <label>Slug</label>
                  <input type="text" value={slug} onChange={(e) => setSlug(slugify(e.target.value))} className="ed-slug-mono" />
                </div>
              </div>
            )}
          </div>

          {aiResult && (
            <div className="ai-result-info">
              <span>ü§ñ {aiResult.model}</span>
              <span>¬∑ {aiResult.tokensIn}‚Üí{aiResult.tokensOut} tokens</span>
            </div>
          )}
        </div>

        {/* RIGHT: AI Sidebar */}
        {showAI && (
          <div className="editor-right">
            <AISidebar
              editor={editorRef.current as import('@tiptap/react').Editor | null}
              onGenerate={handleAIGenerate}
              prefilledPrompt={prefilledPrompt}
              autoGenerate={autoGenerate}
            />
          </div>
        )}
      </div>

      {/* Floating AI toggle */}
      <button className="ai-toggle-btn" onClick={() => setShowAI(!showAI)} title="Toggle AI Co-Pilot">
        {showAI ? '‚úï' : 'ü§ñ'} {showAI ? '' : 'AI'}
      </button>

      {/* Schedule modal */}
      {showSchedule && (
        <div className="ed-modal-overlay" onClick={(e) => { if (e.target === e.currentTarget) setShowSchedule(false) }}>
          <div className="ed-modal">
            <div className="ed-modal-head">
              <div className="ed-modal-title">üìÖ Schedule Article</div>
              <button className="ed-modal-close" onClick={() => setShowSchedule(false)}>√ó</button>
            </div>
            <div className="ed-modal-body">
              <label className="ed-modal-label">Publish date and time</label>
              <input type="datetime-local" className="ed-schedule-input" value={scheduledAt}
                onChange={(e) => setScheduledAt(e.target.value)} min={new Date().toISOString().slice(0, 16)} />
              {scheduledAt && (
                <div className="ed-schedule-preview">
                  Will publish on {new Date(scheduledAt).toLocaleString('en-GB', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' })}
                </div>
              )}
              <div className="ed-modal-actions">
                <button className="ed-btn ed-btn-secondary" onClick={() => { setScheduledAt(''); setShowSchedule(false) }}>Clear</button>
                <button className="ed-btn ed-btn-primary" disabled={!scheduledAt}
                  onClick={() => { handleSave('SCHEDULED'); setShowSchedule(false) }}>üìÖ Schedule</button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
